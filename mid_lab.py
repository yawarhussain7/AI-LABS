# -*- coding: utf-8 -*-
"""Mid-Lab.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1nVVwRvuFzvS8De1u3GIXrMl44eqb6ThQ
"""

from collections import deque
from math import ceil
import time
import heapq

# get student information
def student_Info():
  print("Name: Yawar Hussain \n Registration number : SP23-BSE-122 \nSection: BSE-6C");
from collections import deque
from math import ceil
import heapq
import time

# Total missionaries and cannibals
Total_Missionaries= 3
Total_Cannibals = 3

# Possible boat moves: (missionaries, cannibals)
ACTIONS = [(2,0), (0,2), (1,0), (0,1), (1,1)]


def valid_state(state):
    M_left, C_left, boat = state
    M_right = Total_Missionaries- M_left
    C_right = Total_Cannibals - C_left

    # Must be within valid count range
    if not (0 <= M_left <= Total_Missionaries and 0 <= C_left <= Total_Cannibals):
        return False

    # Check left bank safety
    if M_left > 0 and C_left > M_left:
        return False

    # Check right bank safety
    if M_right > 0 and C_right > M_right:
        return False

    return True


def successors(state):
    M_left, C_left, boat = state
    succ = []

    # If boat on left, subtract people from left. If on right, add them back.
    direction = -1 if boat == 1 else 1

    for m, c in ACTIONS:
        new_M_left = M_left + direction * m
        new_C_left = C_left + direction * c
        new_boat = 1 - boat
        new_state = (new_M_left, new_C_left, new_boat)

        if valid_state(new_state):
            succ.append(new_state)

    return succ


def reconstruct_path(parents, state):
    path = [state]
    while parents[state] is not None:
        state = parents[state]
        path.append(state)
    return list(reversed(path))


def BFS(start, goal):
    start_time = time.time()
    queue = deque([start])
    parents = {start: None}
    expanded = 0

    while queue:
        state = queue.popleft()
        expanded += 1

        if state == goal:
            return reconstruct_path(parents, state), expanded, time.time() - start_time

        for nxt in successors(state):
            if nxt not in parents:
                parents[nxt] = state
                queue.append(nxt)

    return None, expanded, time.time() - start_time


def DFS(start, goal):
    start_time = time.time()
    visited = set()
    path = []
    expanded = 0

    def search(state):
        nonlocal expanded
        expanded += 1
        visited.add(state)
        path.append(state)

        if state == goal:
            return True

        for nxt in successors(state):
            if nxt not in visited:
                if search(nxt):
                    return True

        path.pop()
        return False

    search(start)
    return path, expanded, time.time() - start_time


def heuristic(state):
    M_left, C_left, b = state
    return ceil((M_left + C_left) / 2)


def a_star(start, goal):
    start_time = time.time()
    open_heap = []
    heapq.heappush(open_heap, (heuristic(start), 0, start))
    parents = {start: None}
    g_score = {start: 0}
    expanded = 0
    closed = set()

    while open_heap:
        f, g, state = heapq.heappop(open_heap)

        if state in closed:
            continue
        expanded += 1
        if state == goal:
            return reconstruct_path(parents, state), expanded, time.time() - start_time

        closed.add(state)

        for nxt in successors(state):
            temp_g = g_score[state] + 1
            if temp_g < g_score.get(nxt, float('inf')):
                parents[nxt] = state
                g_score[nxt] = temp_g
                heapq.heappush(open_heap, (temp_g + heuristic(nxt), temp_g, nxt))

    return None, expanded, time.time() - start_time


def pretty_print(path):
    for step, (M_left, C_left, boat) in enumerate(path):
        M_right = Total_Missionaries- M_left
        C_right = Total_Cannibals - C_left
        side = "Left" if boat == 1 else "Right"
        print(f"Step {step}:  Left(M={M_left}, C={C_left}) | Right(M={M_right}, C={C_right}) | Boat: {side}")


# Run Searches
start = (3, 3, 1)   # All on left
goal = (0, 0, 0)    # All on right
print("\n=== Student Details ===")
student_Info()

print("\n=== BFS ===")
p, e, t = BFS(start, goal)
pretty_print(p)
print(f"\nMoves: {len(p)-1}, Expanded: {e}, Time: {t:.6f}s")

print("\n=== DFS ===")
p, e, t = DFS(start, goal)
pretty_print(p)
print(f"\nMoves: {len(p)-1}, Expanded: {e}, Time: {t:.6f}s")

print("\n=== A* ===")
p, e, t = a_star(start, goal)
pretty_print(p)
print(f"\nMoves: {len(p)-1}, Expanded: {e}, Time: {t:.6f}s")