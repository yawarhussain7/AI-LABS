# -*- coding: utf-8 -*-
"""Reproduce(BFS & DFS) .ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1h-HoKVs-8bkj6IlSx8a0sqriwA2t2aQb
"""

from collections import deque

# list of the cities
Gilgit_cities = {
    'Gilgit': ['Skardu'],
    'Skardu': ['Kharmang', 'Khaplu'],
    'Kharmang': ['Astor', 'Nagar', 'Skardu'],
    'Astor': ['Khaplu', 'Ghizer'],
    'Ghizer': ['Diamer'],
    'Diamer': ['Hunza', 'Roundu'],
    'Hunza': ['Astor', 'Shiger'],
    'Shiger': ['Skardu']
}

# BFS
def BFS(graph, start, goal):
    queue = deque([[start]])
    # create a set which holde the visited cities to avoid repeation
    visited = set()

    while queue:
        path = queue.popleft()
        current_city = path[-1]
        # if we find the goal then skip more search and return the goal
        if current_city == goal:
            return path

        # if the current city not visited then add into the visited set
        if current_city not in visited:
            visited.add(current_city)
            # check for each node parallely
            for neighbor in graph.get(current_city, []):
                new_path = list(path)
                new_path.append(neighbor)
                queue.append(new_path)

    return None


  # DFS

def DFS(graph,start,goal,path=None,visited=None):
    # if there is not path list then create empty path list to track the path
    if path is None:
      path = []
  # if there is no visited set then create empty set to track the visited node
    if visited is None:
      visited = set()
    # append the first node into path list
    path.append(start)
    # append node into visited list after visit it
    visited.add(start)
    # if you reach the goal then return the path and skip searching
    if start == goal:
      return path
    # ensure deep searching untill reach the goal
    for neighbor in graph.get(start,[]):
      if neighbor not in visited:
        #recursively call :
        # replace start with neighbor node
        # rest of the the node are path and visited are copy
        result = DFS(graph,neighbor,goal,path.copy(),visited.copy())
        # if result found then return result
        if result:
          return result
    # if result not found then return None
    return None

# Calling
start_city = "Gilgit"
goal_city = "Khaplu"
# invoke BFS
bfs_result = BFS(Gilgit_cities, start_city, goal_city)

print(f'BFS shortest path from {start_city} to {goal_city} : {bfs_result}')
# invoke DFS
dfs_result = (Gilgit_cities,start_city,goal_city)
print(f'DFS shortest path from {start_city} to {goal_city} : {dfs_result}')

